1.implementtaion of FSM?
#include <stdio.h>
#include <string.h>

// FSM States
enum State { START, CHECKING, ACCEPT, REJECT };

int checkBinaryString(const char *str) {
    int len = strlen(str);
    enum State state = START;

    // Check for empty string
    if (len == 0) return 0;

    // Step 1: Check starting character
    if (str[0] == '0') {
        state = CHECKING;
    } else {
        state = REJECT;
    }

    // Step 2: Loop through the middle characters
    for (int i = 1; i < len; i++) {
        if (str[i] != '0' && str[i] != '1') {
            state = REJECT;
            break; // invalid character
        }
    }

    // Step 3: Check last character
    if (state != REJECT && str[len - 1] == '1') {
        state = ACCEPT;
    } else {
        state = REJECT;
    }

    return (state == ACCEPT);
}

int main() {
    char input[100];

    printf("Enter a binary string: ");
    scanf("%s", input);

    if (checkBinaryString(input))
        printf("✅ Accepted: Starts with 0 and ends with 1.\n");
    else
        printf("❌ Rejected: Doesn't meet the condition.\n");

    return 0;
}
===============================================================================================================
2.Design and implementation of Tables used in a Translator

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// Define structure for Symbol Table Entry
struct Symbol {
    char name[20];     // variable name
    char type[10];     // data type
    char value[20];    // value (stored as string for simplicity)
};

// Global array to act as a table
struct Symbol table[100];
int count = 0;

// Function to add entry
void insert(char name[], char type[], char value[]) {
    strcpy(table[count].name, name);
    strcpy(table[count].type, type);
    strcpy(table[count].value, value);
    count++;
}

// Function to search for an identifier
int search(char name[]) {
    for(int i = 0; i < count; i++) {
        if(strcmp(table[i].name, name) == 0)
            return i;
    }
    return -1;
}

// Function to display the symbol table
void display() {
    printf("\nSymbol Table:\n");
    printf("%-10s %-10s %-10s\n", "Name", "Type", "Value");
    for(int i = 0; i < count; i++) {
        printf("%-10s %-10s %-10s\n", table[i].name, table[i].type, table[i].value);
    }
}

int main() {
    insert("a", "int", "5");
    insert("b", "float", "2.5");

    display();

    // Search for a variable
    char search_name[20];
    printf("\nEnter variable to search: ");
    scanf("%s", search_name);
    int index = search(search_name);
    if(index != -1)
        printf("Found %s of type %s with value %s\n", table[index].name, table[index].type, table[index].value);
    else
        printf("Variable not found.\n");

    return 0;
}

================================================================================================================
3.write a program to implement NFA that recognizes identifiers,constants,and operators??
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int isIdentifier(char str[]) {
    if (!isalpha(str[0])) return 0; // Must start with a letter
    for (int i = 1; i < strlen(str); i++) {
        if (!isalnum(str[i])) return 0; // Rest must be letters or digits
    }
    return 1;
}

int isConstant(char str[]) {
    for (int i = 0; i < strlen(str); i++) {
        if (!isdigit(str[i])) return 0; // All must be digits
    }
    return 1;
}

int isOperator(char str[]) {
    char operators[] = "+-*/=";
    return (strlen(str) == 1 && strchr(operators, str[0]) != NULL);
}

int main() {
    char input[100];

    printf("Enter a token (word): ");
    scanf("%s", input);

    if (isIdentifier(input))
        printf("✅ '%s' is a valid IDENTIFIER.\n", input);
    else if (isConstant(input))
        printf("✅ '%s' is a valid CONSTANT.\n", input);
    else if (isOperator(input))
        printf("✅ '%s' is a valid OPERATOR.\n", input);
    else
        printf("❌ '%s' is NOT a valid identifier, constant, or operator.\n", input);

    return 0;
}

============================================================================================================
4.write a program to implement DFA that recognizes identifiers,constants,and operators??
#include <stdio.h>
#include <ctype.h>
#include <string.h>

// DFA for identifier
int isIdentifier_DFA(char str[]) {
    int state = 0;
    for (int i = 0; i < strlen(str); i++) {
        char ch = str[i];
        switch(state) {
            case 0:
                if (isalpha(ch))
                    state = 1;
                else
                    return 0;
                break;
            case 1:
                if (isalnum(ch))
                    state = 1;
                else
                    return 0;
                break;
        }
    }
    return (state == 1);
}

// DFA for constant
int isConstant_DFA(char str[]) {
    int state = 0;
    for (int i = 0; i < strlen(str); i++) {
        char ch = str[i];
        switch(state) {
            case 0:
            case 1:
                if (isdigit(ch))
                    state = 1;
                else
                    return 0;
                break;
        }
    }
    return (state == 1);
}

// DFA for operator
int isOperator_DFA(char str[]) {
    if (strlen(str) == 1) {
        char ch = str[0];
        if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '=')
            return 1;
    }
    return 0;
}

int main() {
    char token[100];

    printf("Enter a token: ");
    scanf("%s", token);

    if (isIdentifier_DFA(token))
        printf("✅ '%s' is a valid IDENTIFIER (DFA).\n", token);
    else if (isConstant_DFA(token))
        printf("✅ '%s' is a valid CONSTANT (DFA).\n", token);
    else if (isOperator_DFA(token))
        printf("✅ '%s' is a valid OPERATOR (DFA).\n", token);
    else
        printf("❌ '%s' is INVALID.\n", token);

    return 0;
}

===============================================================================================================
5.developemnt and implementation of lexical analysis block?
#include <stdio.h>
#include <ctype.h>
#include <string.h>

// Keywords list
char keywords[10][10] = {"int", "float", "return", "if", "else", "while", "for"};

int isKeyword(char *str) {
    for (int i = 0; i < 10; i++) {
        if (strcmp(str, keywords[i]) == 0)
            return 1;
    }
    return 0;
}

int main() {
    char code[100], token[20];
    int i = 0, j = 0;

    printf("Enter a line of code: ");
    fgets(code, sizeof(code), stdin);

    while (code[i] != '\0') {
        if (isspace(code[i])) {
            i++;
            continue;
        }

        // Identifier / Keyword
        if (isalpha(code[i]) || code[i] == '_') {
            j = 0;
            while (isalnum(code[i]) || code[i] == '_') {
                token[j++] = code[i++];
            }
            token[j] = '\0';

            if (isKeyword(token))
                printf("Keyword     : %s\n", token);
            else
                printf("Identifier  : %s\n", token);
        }
        // Numbers
        else if (isdigit(code[i])) {
            j = 0;
            while (isdigit(code[i])) {
                token[j++] = code[i++];
            }
            token[j] = '\0';
            printf("Constant    : %s\n", token);
        }
        // Operators and Symbols
        else {
            switch (code[i]) {
                case '+': case '-': case '*': case '/': case '=':
                    printf("Operator    : %c\n", code[i]);
                    break;
                case ';': case '(': case ')': case '{': case '}':
                    printf("Separator   : %c\n", code[i]);
                    break;
                default:
                    printf("Unknown     : %c\n", code[i]);
            }
            i++;
        }
    }

    return 0;
}
===========================================================================================================
7.Implement a program for predictive parsing algorithm?
#include <stdio.h>
#include <string.h>

char stack[100];
int top = -1;

// Push onto stack
void push(char c) {
    stack[++top] = c;
}

// Pop from stack
char pop() {
    return stack[top--];
}

// Peek top of stack
char peek() {
    return stack[top];
}

// Function to print current stack contents
void printStack() {
    for (int i = 0; i <= top; i++) {
        printf("%c", stack[i]);
    }
}

// Main parse function using predictive parsing
void parseInput(char input[]) {
    int i = 0;
    char symbol, current;

    push('$');   // End marker
    push('E');   // Start symbol

    printf("\nStack\t\tInput\t\tAction\n");
    printf("-----------------------------------------------\n");

    while (top >= 0) {
        symbol = peek();   // Top of stack
        current = input[i];  // Current input character

        printStack();
        printf("\t\t%s\t\t", &input[i]);

        // Terminal or end marker match
        if ((symbol == current) || (symbol == '$' && current == '$')) {
            pop();
            i++;
            printf("Match %c\n", current);
        }

        // Non-terminal rules
        else if (symbol == 'E') {
            if (current == 'i' || current == '(') {
                pop();
                push('e');  // E'
                push('T');
                printf("E → T E'\n");
            } else {
                printf("Error: No rule for E\n");
                break;
            }
        }
        else if (symbol == 'e') {  // E'
            if (current == '+') {
                pop();
                push('e'); push('T'); push('+');
                printf("E' → + T E'\n");
            } else if (current == ')' || current == '$') {
                pop();  // E' → ε
                printf("E' → ε\n");
            } else {
                printf("Error: No rule for E'\n");
                break;
            }
        }
        else if (symbol == 'T') {
            if (current == 'i' || current == '(') {
                pop();
                push('t'); push('F');  // T → F T'
                printf("T → F T'\n");
            } else {
                printf("Error: No rule for T\n");
                break;
            }
        }
        else if (symbol == 't') {  // T'
            if (current == '*') {
                pop();
                push('t'); push('F'); push('*');
                printf("T' → * F T'\n");
            } else if (current == '+' || current == ')' || current == '$') {
                pop();  // T' → ε
                printf("T' → ε\n");
            } else {
                printf("Error: No rule for T'\n");
                break;
            }
        }
        else if (symbol == 'F') {
            if (current == 'i') {
                pop();
                push('i');  // F → id
                printf("F → id\n");
            } else if (current == '(') {
                pop();
                push(')'); push('E'); push('(');  // F → ( E )
                printf("F → ( E )\n");
            } else {
                printf("Error: No rule for F\n");
                break;
            }
        }
        else {
            printf("Error: Unexpected symbol on stack\n");
            break;
        }
    }

    // Final validation
    if (peek() == '$' && input[i] == '$') {
        printf("\n✅ Input string is Accepted!\n");
    } else {
        printf("\n❌ Input string is Rejected!\n");
    }
}

int main() {
    char input[100];

    printf("Enter input string (use i for id, end with $): ");
    scanf("%s", input);

    parseInput(input);

    return 0;
}

=============================================================================================================
8.implement a program for the design of recursive descent parser
#include <stdio.h>
#include <string.h>

char input[100];
int i = 0;

// Function declarations for non-terminals
void E();
void Eprime();
void T();
void Tprime();
void F();

void error() {
    printf("\n❌ Syntax Error at position %d\n", i);
    exit(1);
}

void match(char expected) {
    if (input[i] == expected) {
        i++;
    } else {
        error();
    }
}

// E → T E'
void E() {
    T();
    Eprime();
}

// E' → + T E' | ε
void Eprime() {
    if (input[i] == '+') {
        match('+');
        T();
        Eprime();
    }
    // else epsilon (do nothing)
}

// T → F T'
void T() {
    F();
    Tprime();
}

// T' → * F T' | ε
void Tprime() {
    if (input[i] == '*') {
        match('*');
        F();
        Tprime();
    }
    // else epsilon (do nothing)
}

// F → ( E ) | i
void F() {
    if (input[i] == '(') {
        match('(');
        E();
        match(')');
    } else if (input[i] == 'i') {
        match('i');
    } else {
        error();
    }
}

int main() {
    printf("Enter the input string (use 'i' for id and end with $): ");
    scanf("%s", input);

    E();  // Start parsing from E

    if (input[i] == '$') {
        printf("\n✅ Input string is Accepted!\n");
    } else {
        printf("\n❌ Input string is Rejected. Extra characters found!\n");
    }

    return 0;
}

===============================================================================================================
12.implememtation of generating three address code ?
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int tempVar = 1;

// Function to generate temporary variable name
char* newTemp(char *t) {
    sprintf(t, "t%d", tempVar++);
    return t;
}

int main() {
    char expr[100];
    char op[] = {'*', '/', '+', '-'};
    int i, j;

    printf("Enter an expression (e.g. a+b*c-d): ");
    scanf("%s", expr);

    int len = strlen(expr);
    char newExpr[100];
    strcpy(newExpr, expr);

    // Loop through all operators in precedence order
    for (j = 0; j < 4; j++) {
        for (i = 0; i < len; i++) {
            if (newExpr[i] == op[j]) {
                char left = newExpr[i - 1];
                char right = newExpr[i + 1];
                char temp[5];

                // Create a new temp variable
                printf("%s = %c %c %c\n", newTemp(temp), left, newExpr[i], right);

                // Replace the sub-expression in original string with the new temp
                newExpr[i - 1] = temp[0];  // t1
                // Shift the rest of the string
                int k = i + 2, l = i;
                while (newExpr[k] != '\0') {
                    newExpr[l++] = newExpr[k++];
                }
                newExpr[l] = '\0';
                len = strlen(newExpr);
                i = 0; // Restart from beginning for new expression
            }
        }
    }

    return 0;
}






=========================


1.	Write a python program to import and export data using Pandas Library Functions
import pandas as pd

# Step 1: Import data from a CSV file
# (You can replace 'input.csv' with your actual file name)
try:
    df = pd.read_csv('input.csv')
    print("Data imported successfully!\n")
    print("Preview of imported data:")
    print(df.head())  # Display the first 5 rows
except FileNotFoundError:
    print("The file 'input.csv' was not found. Please check the path.")

# Step 2: Perform a basic operation (e.g., add a new column)
if 'df' in locals():
    df['Total'] = df.select_dtypes(include='number').sum(axis=1)

    # Step 3: Export the modified data to a new CSV file
    df.to_csv('output.csv', index=False)
    print("\nModified data exported successfully to 'output.csv'")
-----------------------------------------------------------------------------------------------------------------------

2.	Apply suitable classifier model to classify the credit status to be good or bad on German credit dataset.csv, create confusion matrix to measure the accuracy of the model (using Logistic Regression/SVM/Naïve Bayes).

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import confusion_matrix, accuracy_score

# Load the dataset
df = pd.read_csv("German credit dataset.csv")

# Encode target labels: 'good' -> 1, 'bad' -> 0
df['Creditability'] = LabelEncoder().fit_transform(df['Creditability'])

# Convert all object (text) columns to numbers
for col in df.select_dtypes(include='object').columns:
    df[col] = LabelEncoder().fit_transform(df[col])

# Split features and target
X = df.drop('Creditability', axis=1)
y = df['Creditability']

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1)

# Train the model
model = LogisticRegression()
model.fit(X_train, y_train)

# Make predictions
y_pred = model.predict(X_test)

# Confusion matrix and accuracy
cm = confusion_matrix(y_test, y_pred)
acc = accuracy_score(y_test, y_pred)
-----------------------------------------------------------------------------------------------------------------------
3. Demonstrate the following data pre-processing techniques on the given dataset 
a. Standardization b. normalization c. summarization d. de-duplication e. imputation 

import pandas as pd
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.impute import SimpleImputer

# Step 1: Load your dataset
df = pd.read_csv("German credit dataset.csv")

print("\nOriginal Data (first 5 rows):")
print(df.head())

# Step 2: Standardization (mean = 0, std = 1)
scaler = StandardScaler()
# We'll apply it to numeric columns only
numeric_cols = df.select_dtypes(include=['int64', 'float64']).columns
df_standardized = df.copy()
df_standardized[numeric_cols] = scaler.fit_transform(df[numeric_cols])
print("\nAfter Standardization (first 5 rows):")
print(df_standardized[numeric_cols].head())

# Step 3: Normalization (scales values between 0 and 1)
normalizer = MinMaxScaler()
df_normalized = df.copy()
df_normalized[numeric_cols] = normalizer.fit_transform(df[numeric_cols])
print("\nAfter Normalization (first 5 rows):")
print(df_normalized[numeric_cols].head())

# Step 4: Summarization (mean, median, std, etc.)
print("\nSummary Statistics:")
print(df.describe())

# Step 5: De-duplication
print("\nShape before de-duplication:", df.shape)
df_no_duplicates = df.drop_duplicates()
print("Shape after de-duplication:", df_no_duplicates.shape)

# Step 6: Imputation (fill missing values with mean for numeric columns)
# First, let's introduce some missing values for demonstration
import numpy as np
df_missing = df.copy()
df_missing.loc[0:2, numeric_cols[0]] = np.nan  # introducing NaNs in the first column

print(f"\nBefore Imputation (missing values in '{numeric_cols[0]}'):")
print(df_missing[[numeric_cols[0]]].head())

# Apply imputation
imputer = SimpleImputer(strategy='mean')
df_missing[numeric_cols] = imputer.fit_transform(df_missing[numeric_cols])

print("\nAfter Imputation:")
print(df_missing[[numeric_cols[0]]].head())
-----------------------------------------------------------------------------------------------------------------------
4.Demonstrate the capability of PCA and LDA in dimensionality reduction.

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris
from sklearn.decomposition import PCA
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA

# Load the Iris dataset
iris = load_iris()
X = iris.data      # Features
y = iris.target    # Labels
target_names = iris.target_names

# ----- PCA -----
pca = PCA(n_components=2)  # Reduce to 2 components
X_pca = pca.fit_transform(X)

# Plot PCA result
plt.figure(figsize=(8, 4))
plt.subplot(1, 2, 1)
for i, target in enumerate(np.unique(y)):
    plt.scatter(X_pca[y == target, 0], X_pca[y == target, 1], label=target_names[i])
plt.title('PCA: Dimension Reduction')
plt.xlabel('PC 1')
plt.ylabel('PC 2')
plt.legend()

# ----- LDA -----
lda = LDA(n_components=2)
X_lda = lda.fit_transform(X, y)

# Plot LDA result
plt.subplot(1, 2, 2)
for i, target in enumerate(np.unique(y)):
    plt.scatter(X_lda[y == target, 0], X_lda[y == target, 1], label=target_names[i])
plt.title('LDA: Dimension Reduction')
plt.xlabel('LD 1')
plt.ylabel('LD 2')
plt.legend()

plt.tight_layout()
plt.show()

-----------------------------------------------------------------------------------------------------------------------
5. Implement Find-S algorithm and Candidate elimination algorithm. 

def find_s_algorithm(examples):
    # Start with the first positive example
    for i in range(len(examples)):
        if examples[i][-1] == 'Yes':
            hypothesis = examples[i][:-1]
            break

    # Generalize hypothesis for other positive examples
    for i in range(len(examples)):
        if examples[i][-1] == 'Yes':
            for j in range(len(hypothesis)):
                if examples[i][j] != hypothesis[j]:
                    hypothesis[j] = '?'
    return hypothesis

# Sample training data
data = [
    ['Sunny', 'Warm', 'Normal', 'Strong', 'Warm', 'Same', 'Yes'],
    ['Sunny', 'Warm', 'High', 'Strong', 'Warm', 'Same', 'Yes'],
    ['Rainy', 'Cold', 'High', 'Strong', 'Warm', 'Change', 'No'],
    ['Sunny', 'Warm', 'High', 'Strong', 'Cool', 'Change', 'Yes']
]

hypothesis = find_s_algorithm(data)
print("Final Hypothesis using Find-S:", hypothesis)


def candidate_elimination(examples):
    domains = [list(set([x[i] for x in examples])) for i in range(len(examples[0])-1)]
    S = examples[0][:-1] if examples[0][-1] == 'Yes' else ['∅'] * (len(examples[0]) - 1)
    G = [['?' for _ in range(len(S))]]

    for i in range(1, len(examples)):
        x = examples[i][:-1]
        label = examples[i][-1]

        if label == 'Yes':
            for j in range(len(S)):
                if S[j] != x[j]:
                    S[j] = '?'
            G = [g for g in G if all(s == '?' or g[k] == '?' or s == g[k] for k, s in enumerate(S))]
        else:  # label == 'No'
            new_G = []
            for g in G:
                for j in range(len(g)):
                    if g[j] == '?':
                        for value in domains[j]:
                            if value != x[j]:
                                new_hypo = g[:]
                                new_hypo[j] = value
                                if all(S[k] == '?' or new_hypo[k] == '?' or new_hypo[k] == S[k] for k in range(len(S))):
                                    new_G.append(new_hypo)
            G = new_G
    return S, G

S_final, G_final = candidate_elimination(data)
print("Final Specific Hypothesis (S):", S_final)
print("Final General Hypotheses (G):", G_final)

-----------------------------------------------------------------------------------------------------------------------
6.Apply train set split and develop a regression model to predict the sold price of players using imb381ipl2013.csv build a correlation matrix between all the numeric features in dataset and visualize the heatmap. RMSE of train and test data. 

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

# Load dataset
df = pd.read_csv('imb381ipl2013.csv')

# Clean and select numeric columns only
numeric_df = df.select_dtypes(include=[np.number]).dropna()

# Show correlation matrix
corr_matrix = numeric_df.corr()

# 🔥 Heatmap
plt.figure(figsize=(10, 6))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm')
plt.title('Correlation Matrix Heatmap')
plt.show()

# Predict 'sold_price' using other numeric features
X = numeric_df.drop('sold_price', axis=1)
y = numeric_df['sold_price']

# 🧪 Train-Test Split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# ✅ Train the model
model = LinearRegression()
model.fit(X_train, y_train)

# Predict
y_train_pred = model.predict(X_train)
y_test_pred = model.predict(X_test)

# 🎯 RMSE Calculation
train_rmse = np.sqrt(mean_squared_error(y_train, y_train_pred))
test_rmse = np.sqrt(mean_squared_error(y_test, y_test_pred))

print("Train RMSE:", round(train_rmse, 2))
print("Test RMSE:", round(test_rmse, 2))
-----------------------------------------------------------------------------------------------------------------------
7. Demonstrate regression technique to predict the responses at unknown locations by fitting the linear and polynomial regression surfaces. Extract error measures and plot the residuals. Further, add a regulizer and demonstrate the reduction in the variance. (Ridge and LASSO) 

import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression, Ridge, Lasso
from sklearn.preprocessing import PolynomialFeatures
from sklearn.metrics import mean_squared_error

# 1. Simulate a nonlinear dataset
np.random.seed(1)
X = np.sort(5 * np.random.rand(100, 1), axis=0)
y = 2 * X**2 + 3 * X + 5 + np.random.randn(100, 1) * 4  # true equation + noise

# 2. Split data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 3. Linear Regression
lin_model = LinearRegression()
lin_model.fit(X_train, y_train)
y_pred_lin = lin_model.predict(X_test)

# 4. Polynomial Regression (degree 2)
poly = PolynomialFeatures(degree=2)
X_poly_train = poly.fit_transform(X_train)
X_poly_test = poly.transform(X_test)

poly_model = LinearRegression()
poly_model.fit(X_poly_train, y_train)
y_pred_poly = poly_model.predict(X_poly_test)

# 5. Ridge Regression
ridge_model = Ridge(alpha=1.0)
ridge_model.fit(X_poly_train, y_train)
y_pred_ridge = ridge_model.predict(X_poly_test)

# 6. LASSO Regression
lasso_model = Lasso(alpha=0.1)
lasso_model.fit(X_poly_train, y_train)
y_pred_lasso = lasso_model.predict(X_poly_test)

# 7. Error Measures (RMSE)
rmse_lin = np.sqrt(mean_squared_error(y_test, y_pred_lin))
rmse_poly = np.sqrt(mean_squared_error(y_test, y_pred_poly))
rmse_ridge = np.sqrt(mean_squared_error(y_test, y_pred_ridge))
rmse_lasso = np.sqrt(mean_squared_error(y_test, y_pred_lasso))

print(f"Linear RMSE: {rmse_lin:.2f}")
print(f"Polynomial RMSE: {rmse_poly:.2f}")
print(f"Ridge RMSE: {rmse_ridge:.2f}")
print(f"LASSO RMSE: {rmse_lasso:.2f}")

# 8. Residual Plots
plt.figure(figsize=(10, 6))
plt.subplot(2, 2, 1)
plt.scatter(y_test, y_test - y_pred_lin, color='blue')
plt.title('Residuals: Linear')

plt.subplot(2, 2, 2)
plt.scatter(y_test, y_test - y_pred_poly, color='green')
plt.title('Residuals: Polynomial')

plt.subplot(2, 2, 3)
plt.scatter(y_test, y_test - y_pred_ridge, color='red')
plt.title('Residuals: Ridge')

plt.subplot(2, 2, 4)
plt.scatter(y_test, y_test - y_pred_lasso, color='purple')
plt.title('Residuals: LASSO')

plt.tight_layout()
plt.show()
-----------------------------------------------------------------------------------------------------------------------
8.Implement the K-Means clustering algorithm using Python. You may use a library such as scikit-learn for this purpose.

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.datasets import load_iris
from sklearn.cluster import KMeans

# Load the Iris dataset
iris = load_iris()
X = iris.data
y = iris.target  # Actual species labels (not used by K-Means)

# We'll use only the first two features for visualization
X_2D = X[:, :2]  # sepal length and sepal width

# Apply K-Means clustering
kmeans = KMeans(n_clusters=3, random_state=42)
kmeans.fit(X_2D)
cluster_labels = kmeans.labels_

# Create DataFrame for plotting
df = pd.DataFrame(X_2D, columns=['SepalLength', 'SepalWidth'])
df['Cluster'] = cluster_labels

# Plotting the clusters
plt.figure(figsize=(8, 6))
sns.scatterplot(data=df, x='SepalLength', y='SepalWidth', hue='Cluster', palette='viridis', s=100)
plt.title("K-Means Clustering (using Sepal Length & Width)")
plt.xlabel("Sepal Length (cm)")
plt.ylabel("Sepal Width (cm)")
plt.legend(title='Cluster')
plt.grid(True)
plt.show()
-----------------------------------------------------------------------------------------------------------------------

9. Implement K-NN Algo
# 1. Import necessary libraries
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

# 2. Load the iris dataset
iris = load_iris()
X = iris.data   # Features
y = iris.target # Labels

# 3. Split into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 4. Train the K-NN classifier
k = 3
knn = KNeighborsClassifier(n_neighbors=k)
knn.fit(X_train, y_train)

# 5. Make predictions
y_pred = knn.predict(X_test)

# 6. Accuracy
acc = accuracy_score(y_test, y_pred)
print(f"Accuracy with k={k}: {acc:.2f}")

# 7. Confusion Matrix
cm = confusion_matrix(y_test, y_pred)

# 8. Plot Confusion Matrix
plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, cmap='Blues', fmt='d',
            xticklabels=iris.target_names, yticklabels=iris.target_names)
plt.title("Confusion Matrix")
plt.xlabel("Predicted Label")
plt.ylabel("True Label")
plt.show()
-----------------------------------------------------------------------------------------------------------------------

10. Implement the Agglomerative Hierarchical clustering algorithm using Python. Utilize linkage methods such as ‘ward’, ‘complete’, or ‘average’.

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.datasets import make_blobs
from sklearn.cluster import AgglomerativeClustering
from scipy.cluster.hierarchy import dendrogram, linkage

# 1. Generate sample data
X, _ = make_blobs(n_samples=200, centers=4, cluster_std=1.0, random_state=42)

# 2. Create linkage matrix (for dendrogram)
linkage_matrix = linkage(X, method='ward')

# 3. Plot dendrogram
plt.figure(figsize=(10, 5))
dendrogram(linkage_matrix)
plt.title("Dendrogram (Ward Linkage)")
plt.xlabel("Sample Index")
plt.ylabel("Distance")
plt.show()

# 4. Agglomerative Clustering with Ward linkage
model = AgglomerativeClustering(n_clusters=4, linkage='ward')
labels = model.fit_predict(X)

# 5. Plot clustered data
plt.figure(figsize=(6, 4))
plt.scatter(X[:, 0], X[:, 1], c=labels, cmap='rainbow')
plt.title("Agglomerative Clustering (Ward Linkage)")
plt.xlabel("Feature 1")
plt.ylabel("Feature 2")
plt.grid(True)
plt.show()
-----------------------------------------------------------------------------------------------------------------------

11. Spam Detection: Given email in an inbox, identify those email messages that are spam and those that are not. Having a model of this problem would allow a program to leave non-spam emails in the inbox and move spam emails to a spam folder. (logistic regression) 

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import confusion_matrix, classification_report, accuracy_score
import seaborn as sns
import matplotlib.pyplot as plt

# 1. Load dataset
# You can replace this with your own CSV with 'label' and 'message' columns
df = pd.read_csv("https://raw.githubusercontent.com/justmarkham/pycon-2016-tutorial/master/data/sms.tsv", sep='\t', names=["label", "message"])

# 2. Convert labels to binary
df['label'] = df['label'].map({'ham': 0, 'spam': 1})

# 3. Vectorize the text
vectorizer = CountVectorizer()
X = vectorizer.fit_transform(df['message'])
y = df['label']

# 4. Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 5. Train Logistic Regression model
model = LogisticRegression()
model.fit(X_train, y_train)

# 6. Make predictions
y_pred = model.predict(X_test)

# 7. Evaluate performance
acc = accuracy_score(y_test, y_pred)
print(f"Accuracy: {acc:.2f}")

print("\nClassification Report:")
print(classification_report(y_test, y_pred, target_names=["Not Spam", "Spam"]))

# 8. Confusion matrix
cm = confusion_matrix(y_test, y_pred)

# 9. Plot confusion matrix
plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues", xticklabels=["Not Spam", "Spam"], yticklabels=["Not Spam", "Spam"])
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()

-----------------------------------------------------------------------------------------------------------------------

12. For the glass identification dataset, fit random forest classifier to classify glass type.
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

# 1. Load the glass dataset
url = "https://archive.ics.uci.edu/ml/machine-learning-databases/glass/glass.data"
cols = ['Id', 'RI', 'Na', 'Mg', 'Al', 'Si', 'K', 'Ca', 'Ba', 'Fe', 'Type']
df = pd.read_csv(url, names=cols, index_col=False

# 2. Drop ID column
df.drop('Id', axis=1, inplace=True)

# 3. Features and target
X = df.drop('Type', axis=1)
y = df['Type']

# 4. Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 5. Random Forest model
rf = RandomForestClassifier(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

# 6. Prediction
y_pred = rf.predict(X_test)

# 7. Evaluation
print("Accuracy:", accuracy_score(y_test, y_pred))
print("\nClassification Report:\n", classification_report(y_test, y_pred))

# 8. Confusion Matrix
cm = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(8, 5))
sns.heatmap(cm, annot=True, fmt='d', cmap='viridis')
plt.title("Confusion Matrix - Glass Type")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()





+++++++++++++++++++++++dhruv

1. Implementation of FSM
#include <stdio.h>

int main() {
    char input[100];
    int state = 0;  // Start at q0

    printf("Enter a binary string: ");
    scanf("%s", input);

    for (int i = 0; input[i] != '\0'; i++) {
        char ch = input[i];

        if (ch != '0' && ch != '1') {
            printf("Invalid input! Only 0 and 1 allowed.\n");
            return 1;
        }

        // Transition logic
        if (state == 0) {
            if (ch == '0') state = 1;
            else state = 0;
        }
        else if (state == 1) {
            if (ch == '0') state = 1;
            else state = 2;
        }
        else if (state == 2) {
            if (ch == '0') state = 1;
            else state = 0;
        }
    }

    if (state == 2)
        printf(" Accepted: Ends with 01\n");
    else
        printf(" Rejected\n");

    return 0;
}


2. Design and Implementation of Tables used in a Translator
Opt 1:
#include <stdio.h>
#include <string.h>

int isValidString(char *str) {
    int count_a = 0, count_b = 0;
    int state = 0; // q0

    printf("\nTransition Table\n");
    printf("Current State | Input | Next State\n");
    printf("-------------------------------\n");

    for (int i = 0; str[i] != '\0'; i++) {
        char ch = str[i];

        printf("q%d            |  %c    | ", state, ch);

        if (state == 0) {
            if (ch == 'a') {
                count_a++;
                printf("q0\n");
            } else if (ch == 'b') {
                state = 1;
                count_b++;
                printf("q1\n");
            } else {
                printf("Reject (Invalid character)\n");
                return 0;
            }
        } else if (state == 1) {
            if (ch == 'b') {
                count_b++;
                printf("q1\n");
            } else if (ch == 'a') {
                printf("Reject (a after b)\n");
                return 0;
            } else {
                printf("Reject (Invalid character)\n");
                return 0;
            }
        }
    }

    // Final validation
    if (state == 1 && count_a == count_b && count_a > 0) {
        printf("\nThe string is valid (a^n b^n)\n");
        return 1;
    } else {
        printf("\nThe string is invalid (a^n b^n)\n");
        return 0;
    }
}

int main() {
    char input[100];
    printf("Enter the string: ");
    scanf("%99s", input); // Prevent buffer overflow
    isValidString(input);
    return 0;
}

3.Write a Program to implement NFAs that recognize identifiers, constants and operators
#include <stdio.h>
#include <ctype.h>
#include <string.h>

// NFA for identifier: starts with letter or _, followed by letters, digits or _
int isIdentifier(char *str) {
    if (!isalpha(str[0]) && str[0] != '_')
        return 0;
    for (int i = 1; str[i] != '\0'; i++) {
        if (!isalnum(str[i]) && str[i] != '_')
            return 0;
    }
    return 1;
}

// NFA for constant: integer or float (simple version)
int isConstant(char *str) {
    int i = 0, dot = 0;
    if (str[i] == '-') i++; // support negative numbers
    for (; str[i] != '\0'; i++) {
        if (str[i] == '.') {
            if (dot) return 0; // only one dot allowed
            dot = 1;
        } else if (!isdigit(str[i])) {
            return 0;
        }
    }
    return (i > 0);
}

// NFA for operator: supports +, -, *, /, =, ==, !=, <, <=, >, >=
int isOperator(char *str) {
    if (strcmp(str, "+") == 0 || strcmp(str, "-") == 0 ||
        strcmp(str, "*") == 0 || strcmp(str, "/") == 0 ||
        strcmp(str, "=") == 0 || strcmp(str, "==") == 0 ||
        strcmp(str, "!=") == 0 || strcmp(str, "<") == 0 ||
        strcmp(str, "<=") == 0 || strcmp(str, ">") == 0 ||
        strcmp(str, ">=") == 0)
        return 1;
    return 0;
}

int main() {
    char token[50];

    printf("Enter tokens (type 'exit' to stop):\n");

    while (1) {
        printf("> ");
        scanf("%s", token);
        if (strcmp(token, "exit") == 0)
            break;

        if (isIdentifier(token))
            printf(" Identifier: %s\n", token);
        else if (isConstant(token))
            printf(" Constant: %s\n", token);
        else if (isOperator(token))
            printf("  Operator: %s\n", token);
        else
            printf(" Not recognized: %s\n", token);
    }

    return 0;
}
4. Write a Program to implement DFAs that recognize identifiers, constants and operators

#include <stdio.h>
#include <ctype.h>
#include <string.h>

// DFA for identifier
int isIdentifier(char *str) {
    int i = 0;
    if (!isalpha(str[i]) && str[i] != '_') return 0;
    i++;
    while (str[i] != '\0') {
        if (!isalnum(str[i]) && str[i] != '_') return 0;
        i++;
    }
    return 1;
}

// DFA for constant (integer and float)
int isConstant(char *str) {
    int i = 0, hasDot = 0;
    if (str[i] == '-') i++;  // handle negative numbers

    if (!isdigit(str[i]) && str[i] != '.') return 0;

    for (; str[i] != '\0'; i++) {
        if (str[i] == '.') {
            if (hasDot) return 0;
            hasDot = 1;
        } else if (!isdigit(str[i])) {
            return 0;
        }
    }

    // valid if ends properly and not only '.'
    return (i > 0 && !(hasDot && i == 1));
}

// DFA for operators: +, -, *, /, =, ==, !=, <, <=, >, >=
int isOperator(char *str) {
    if (strcmp(str, "+") == 0 || strcmp(str, "-") == 0 ||
        strcmp(str, "*") == 0 || strcmp(str, "/") == 0 ||
        strcmp(str, "=") == 0 || strcmp(str, "==") == 0 ||
        strcmp(str, "!=") == 0 || strcmp(str, "<") == 0 ||
        strcmp(str, "<=") == 0 || strcmp(str, ">") == 0 ||
        strcmp(str, ">=") == 0)
        return 1;
    return 0;
}

int main() {
    char token[50];

    printf("Enter tokens (type 'exit' to stop):\n");

    while (1) {
        printf("> ");
        scanf("%s", token);

        if (strcmp(token, "exit") == 0)
            break;

        if (isIdentifier(token))
            printf(" Identifier: %s\n", token);
        else if (isConstant(token))
            printf(" Constant: %s\n", token);
        else if (isOperator(token))
            printf("  Operator: %s\n", token);
        else
            printf(" Not recognized: %s\n", token);
    }

    return 0;
}

5. Development and Implementation of Lexical Analysis block
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int isKeyword(char *str) {
    return (
        strcmp(str, "int") == 0 ||
        strcmp(str, "float") == 0 ||
        strcmp(str, "if") == 0 ||
        strcmp(str, "else") == 0 ||
        strcmp(str, "while") == 0 ||
        strcmp(str, "return") == 0
    );
}

int isOperatorChar(char ch) {
    return (ch == '+' || ch == '-' || ch == '*' || ch == '/' ||
            ch == '=' || ch == '!' || ch == '<' || ch == '>');
}

int isSeparator(char ch) {
    return (ch == '(' || ch == ')' || ch == '{' || ch == '}' ||
            ch == ',' || ch == ';');
}

int isOperator(char *str) {
    return (
        strcmp(str, "+") == 0 || strcmp(str, "-") == 0 ||
        strcmp(str, "*") == 0 || strcmp(str, "/") == 0 ||
        strcmp(str, "=") == 0 || strcmp(str, "==") == 0 ||
        strcmp(str, "!=") == 0 || strcmp(str, "<") == 0 ||
        strcmp(str, "<=") == 0 || strcmp(str, ">") == 0 ||
        strcmp(str, ">=") == 0
    );
}

int isConstant(char *str) {
    int i = 0, dot = 0;
    if (str[i] == '-') i++;
    for (; str[i] != '\0'; i++) {
        if (str[i] == '.') {
            if (dot) return 0;
            dot = 1;
        } else if (!isdigit(str[i])) return 0;
    }
    return (i > 0);
}

int isIdentifier(char *str) {
    if (!isalpha(str[0]) && str[0] != '_') return 0;
    for (int i = 1; str[i] != '\0'; i++) {
        if (!isalnum(str[i]) && str[i] != '_') return 0;
    }
    return 1;
}

void analyze(char *code) {
    int i = 0;
    char temp[100];
    int k = 0;

    while (code[i] != '\0') {
        char ch = code[i];

        // Skip whitespaces
        if (ch == ' ' || ch == '\n' || ch == '\t') {
            i++;
            continue;
        }

        // Separators
        if (isSeparator(ch)) {
            printf("Separator: %c\n", ch);
            i++;
            continue;
        }

        // Operators
        if (isOperatorChar(ch)) {
            temp[0] = ch;
            temp[1] = '\0';
            if ((ch == '=' || ch == '!' || ch == '<' || ch == '>') && code[i+1] == '=') {
                temp[1] = '=';
                temp[2] = '\0';
                i++;
            }
            if (isOperator(temp)) {
                printf("Operator: %s\n", temp);
            }
            i++;
            continue;
        }

        // Identifiers / Keywords / Constants
        if (isalnum(ch) || ch == '_' || ch == '.') {
            k = 0;
            while (isalnum(code[i]) || code[i] == '_' || code[i] == '.') {
                temp[k++] = code[i++];
            }
            temp[k] = '\0';

            if (isKeyword(temp)) {
                printf("Keyword: %s\n", temp);
            } else if (isConstant(temp)) {
                printf("Constant: %s\n", temp);
            } else if (isIdentifier(temp)) {
                printf("Identifier: %s\n", temp);
            } else {
                printf("Unknown Token: %s\n", temp);
            }
        } else {
            printf("Unknown Character: %c\n", ch);
            i++;
        }
    }
}
int main() {
    char code[200];

    printf("Enter source code (single line):\n");
    fgets(code, sizeof(code), stdin);

    printf("\n Lexical Analysis Output:\n");
    analyze(code);

    return 0;
}
7. Implement a program for predictive parsing algorithm
code option 1:
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#define MAX 100

char stack[MAX];
int top = -1;

// Stack operations
void push(char c) {
    if (top < MAX - 1)
        stack[++top] = c;
}

char pop() {
    if (top >= 0)
        return stack[top--];
    return '\0';
}

char peek() {
    if (top >= 0)
        return stack[top];
    return '\0';
}

// Predictive parsing table
const char *table[5][6] = {
    /* id     +       *       (       )      $   */
    {"Te",   "",     "",     "Te",   "",     ""},   // E
    {"",     "+Te",  "",     "",     "ε",    "ε"},  // e (E')
    {"Ft",   "",     "",     "Ft",   "",     ""},   // T
    {"",     "ε",    "*Ft",  "",     "ε",    "ε"},  // t (T')
    {"i",    "",     "",     "(E)",  "",     ""}    // F
};

// Map non-terminals to row indices
int rowIndex(char symbol) {
    switch (symbol) {
        case 'E': return 0;
        case 'e': return 1; // E'
        case 'T': return 2;
        case 't': return 3; // T'
        case 'F': return 4;
    }
    return -1;
}

// Map terminals to column indices
int colIndex(char symbol) {
    switch (symbol) {
        case 'i': return 0;  // id
        case '+': return 1;
        case '*': return 2;
        case '(': return 3;
        case ')': return 4;
        case '$': return 5;
    }
    return -1;
}

// Predictive parsing function
void predictiveParse(char *input) {
    push('$');
    push('E'); // Start symbol

    int i = 0;
    char current = input[i];

    printf("\nParsing steps:\n");

    while (peek() != '$') {
        char topSymbol = peek();

        if (topSymbol == current) {
            pop();
            i++;
            current = input[i];
        } else if (topSymbol == 'i' && current == 'i') {
            pop();
            i++;
            current = input[i];
        } else if (isupper(topSymbol) || topSymbol == 'e' || topSymbol == 't') {
            int row = rowIndex(topSymbol);
            int col = colIndex(current);

            if (row == -1 || col == -1 || table[row][col][0] == '\0') {
                printf(" Error: no rule for [%c, %c]\n", topSymbol, current);
                return;
            }

            printf("%c -> %s\n", topSymbol, table[row][col]);
            pop();

            if (strcmp(table[row][col], "ε") != 0) {
                int len = strlen(table[row][col]);
                for (int j = len - 1; j >= 0; j--) {
                    push(table[row][col][j]);
                }
            }

        } else {
            printf(" Syntax Error at '%c'\n", current);
            return;
        }
    }

    if (current == '$')
        printf(" String successfully parsed.\n");
    else
        printf(" String not accepted. Remaining input: %s\n", &input[i]);
}

int main() {
    char input[100];

    printf("Enter input string (use 'i' for id, end with '$'): ");
    scanf("%s", input);

    predictiveParse(input);

    return 0;
}
-----------------------------------------------------------------------------------------------------------------------------------------------
7th code option 2:
#include <stdio.h>
#include <string.h>

char prod[2][10] = { "S->aA", "A->b" };
char nonTerminals[2][10] = { "S", "A" };
char terminals[3][10] = { "a", "b", "$" };

char table[3][4][15]; // 3 rows (S, A + header), 4 columns (a, b, $, + header)

int getRow(char nt) {
    switch (nt) {
        case 'S': return 1;
        case 'A': return 2;
    }
    return 0;
}

int getCol(char t) {
    switch (t) {
        case 'a': return 1;
        case 'b': return 2;
        case '$': return 3;
    }
    return 0;
}

int main() {
    // Initialize table with empty strings
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 4; j++)
            strcpy(table[i][j], " ");

    // Fill headers
    strcpy(table[0][0], " ");
    strcpy(table[0][1], "a");
    strcpy(table[0][2], "b");
    strcpy(table[0][3], "$");

    strcpy(table[1][0], "S");
    strcpy(table[2][0], "A");

    // Fill table using FIRST sets
    strcpy(table[getRow('S')][getCol('a')], "S->aA");
    strcpy(table[getRow('A')][getCol('b')], "A->b");

    // Print the table
    printf("Predictive Parsing Table:\n");
    printf("-----------------------------------------\n");

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            printf("%-12s", table[i][j]);
        }
        printf("\n-----------------------------------------\n");
    }

    return 0;
}

8. Implement a program for the design of Recursive Descent Parser
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

char input[100];
int pos = 0;

char lookahead() {
    while (input[pos] == ' ') pos++;  // skip whitespace
    return input[pos];
}

void match(char expected) {
    if (lookahead() == expected) {
        pos++;
    } else {
        printf("Error: Expected '%c', but found '%c'\n", expected, lookahead());
        exit(1);
    }
}

void E(), EPrime(), T(), TPrime(), F();

void E() {
    T();
    EPrime();
}

void EPrime() {
    if (lookahead() == '+') {
        match('+');
        T();
        EPrime();
    }
    // else: epsilon (do nothing)
}

void T() {
    F();
    TPrime();
}

void TPrime() {
    if (lookahead() == '*') {
        match('*');
        F();
        TPrime();
    }
    // else: epsilon (do nothing)
}

void F() {
    if (lookahead() == '(') {
        match('(');
        E();
        match(')');
    } else if (isalpha(lookahead())) {
        match(lookahead());  // accept single-letter id
    } else {
        printf("Error: Unexpected symbol '%c' in F\n", lookahead());
        exit(1);
    }
}

int main() {
    printf("Enter an expression: ");
    fgets(input, sizeof(input), stdin);

    E();

    if (lookahead() == '\n' || lookahead() == '\0') {
        printf("Parsing successful.\n");
    } else {
        printf("Error: Unexpected input remaining: '%c'\n", lookahead());
    }

    return 0;
}
12. Implementation for generating three address codes.
OPT1:

#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>
#include<string.h>

int tempCount = 1;

void generate(char * input){
    char lhs[10],rhs[50],temp[50];
    sscanf(input, "%[^=]=%s", lhs, rhs);
    char token[50][10];
    int n =0;
    for(int i =0; rhs[i]!='\0';i++){
        char t[2]={rhs[i],'\0'};
        strcpy(token[n++],t);
    }
    for(int i =0 ;i <n ;i++){
        if(!(strcmp(token[i],"*"))|| !(strcmp(token[i],"/"))){
            sprintf(temp, "t%d",tempCount++);
            printf("%s = %s %s %s",temp, token[i-1],token[i],token[i+1]);
            strcpy(token[i-1],temp);
            for(int j= i+2;j<n;j++){
                strcpy(token[j+2],token[j]);
            }
            n-=2;
            i-=1 ;   
        }
    }
    for(int i =0 ;i <n ;i++){
        if(!(strcmp(token[i],"+"))|| !(strcmp(token[i],"-"))){
            sprintf(temp, "t%d",tempCount++);
            printf("%s = %s %s %s",temp, token[i-1],token[i],token[i+1]);
            strcpy(token[i-1],temp);
            for(int j= i+2;j<n;j++){
                strcpy(token[j+2],token[j]);
            }
            n-=2;
            i-=1 ;   
        }
    }
    printf("%s = %s",lhs,token[0]);
}

void main(){
    char expr[100];
    int choice = 0;
    printf("Enter a choice 1. Expression 2. Array\n");
    scanf(" %d",&choice);
    if(choice == 1){
        printf("Enter expression (e.g., a=b+c*d): ");
        scanf("%s", expr);
        generate(expr);
    }
    else if(choice==2){
        int type;
        printf("1. Read (x = y[i])\n2. Write (x[i] = y)\nChoose type: ");
        scanf("%d", &type);
        char x[10], y[10], i[10];
        if (type == 1) {
            printf("Enter x (target): "); s canf("%s", x);
            printf("Enter y (array): "); scanf("%s", y);
            printf("Enter i (index): "); scanf("%s", i);
            printf("%s = %s[%s]\n", x, y, i);
        } else {
            printf("Enter x (array): "); scanf("%s", x);
            printf("Enter i (index): "); scanf("%s", i);
            printf("Enter y (value): "); scanf("%s", y);
            printf("%s[%s] = %s\n", x, i, y);
        }
    }
    
}
OPT2:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

char expr[100];
int pos = 0;
int tempCount = 1;
char tempVar[10];

char* newTemp() {
    sprintf(tempVar, "t%d", tempCount++);
    return strdup(tempVar);
}

void error() {
    printf("Syntax Error at position %d\n", pos);
    exit(1);
}

char* F();       // Factor
char* T();       // Term
char* E();       // Expression

char peek() { return expr[pos]; }
void consume() { pos++; }
void match(char c) { if (peek() == c) consume(); else error(); }

char* F() {
    char *res;
    if (peek() == '(') {
        match('(');
        res = E();
        match(')');
    } else if (isalpha(peek())) {
        char id[2] = {peek(), '\0'};
        consume();
        res = strdup(id);
    } else {
        error();
    }
    return res;
}

char* T() {
    char *left = F();
    while (peek() == '*' || peek() == '/') {
        char op = peek();
        consume();
        char *right = F();
        char *tmp = newTemp();
        printf("%s = %s %c %s\n", tmp, left, op, right);
        left = strdup(tmp);
    }
    return left;
}

char* E() {
    char *left = T();
    while (peek() == '+' || peek() == '-') {
        char op = peek();
        consume();
        char *right = T();
        char *tmp = newTemp();
        printf("%s = %s %c %s\n", tmp, left, op, right);
        left = strdup(tmp);
    }
    return left;
}

void handleExpression() {
    printf("Enter expression (e.g., a=b+c*d): ");
    scanf("%s", expr);

    if (isalpha(expr[0]) && expr[1] == '=') {
        char lhs = expr[0];
        pos = 2;
        char *res = E();
        printf("%c = %s\n", lhs, res);
    } else {
        char *res = E();
        printf("Result in: %s\n", res);
    }
}

void handleArrayAccess() {
    int type;
    printf("1. Read (x = y[i])\n2. Write (x[i] = y)\nChoose type: ");
    scanf("%d", &type);
    char x[10], y[10], i[10];
    if (type == 1) {
        printf("Enter x (target): "); scanf("%s", x);
        printf("Enter y (array): "); scanf("%s", y);
        printf("Enter i (index): "); scanf("%s", i);
        printf("%s = %s[%s]\n", x, y, i);
    } else {
        printf("Enter x (array): "); scanf("%s", x);
        printf("Enter i (index): "); scanf("%s", i);
        printf("Enter y (valu