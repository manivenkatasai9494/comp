1.implementtaion of FSM?
#include <stdio.h>
#include <string.h>

// FSM States
enum State { START, CHECKING, ACCEPT, REJECT };

int checkBinaryString(const char *str) {
    int len = strlen(str);
    enum State state = START;

    // Check for empty string
    if (len == 0) return 0;

    // Step 1: Check starting character
    if (str[0] == '0') {
        state = CHECKING;
    } else {
        state = REJECT;
    }

    // Step 2: Loop through the middle characters
    for (int i = 1; i < len; i++) {
        if (str[i] != '0' && str[i] != '1') {
            state = REJECT;
            break; // invalid character
        }
    }

    // Step 3: Check last character
    if (state != REJECT && str[len - 1] == '1') {
        state = ACCEPT;
    } else {
        state = REJECT;
    }

    return (state == ACCEPT);
}

int main() {
    char input[100];

    printf("Enter a binary string: ");
    scanf("%s", input);

    if (checkBinaryString(input))
        printf("✅ Accepted: Starts with 0 and ends with 1.\n");
    else
        printf("❌ Rejected: Doesn't meet the condition.\n");

    return 0;
}
===============================================================================================================
2.Design and implementation of Tables used in a Translator

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// Define structure for Symbol Table Entry
struct Symbol {
    char name[20];     // variable name
    char type[10];     // data type
    char value[20];    // value (stored as string for simplicity)
};

// Global array to act as a table
struct Symbol table[100];
int count = 0;

// Function to add entry
void insert(char name[], char type[], char value[]) {
    strcpy(table[count].name, name);
    strcpy(table[count].type, type);
    strcpy(table[count].value, value);
    count++;
}

// Function to search for an identifier
int search(char name[]) {
    for(int i = 0; i < count; i++) {
        if(strcmp(table[i].name, name) == 0)
            return i;
    }
    return -1;
}

// Function to display the symbol table
void display() {
    printf("\nSymbol Table:\n");
    printf("%-10s %-10s %-10s\n", "Name", "Type", "Value");
    for(int i = 0; i < count; i++) {
        printf("%-10s %-10s %-10s\n", table[i].name, table[i].type, table[i].value);
    }
}

int main() {
    insert("a", "int", "5");
    insert("b", "float", "2.5");

    display();

    // Search for a variable
    char search_name[20];
    printf("\nEnter variable to search: ");
    scanf("%s", search_name);
    int index = search(search_name);
    if(index != -1)
        printf("Found %s of type %s with value %s\n", table[index].name, table[index].type, table[index].value);
    else
        printf("Variable not found.\n");

    return 0;
}

================================================================================================================
3.write a program to implement NFA that recognizes identifiers,constants,and operators??
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int isIdentifier(char str[]) {
    if (!isalpha(str[0])) return 0; // Must start with a letter
    for (int i = 1; i < strlen(str); i++) {
        if (!isalnum(str[i])) return 0; // Rest must be letters or digits
    }
    return 1;
}

int isConstant(char str[]) {
    for (int i = 0; i < strlen(str); i++) {
        if (!isdigit(str[i])) return 0; // All must be digits
    }
    return 1;
}

int isOperator(char str[]) {
    char operators[] = "+-*/=";
    return (strlen(str) == 1 && strchr(operators, str[0]) != NULL);
}

int main() {
    char input[100];

    printf("Enter a token (word): ");
    scanf("%s", input);

    if (isIdentifier(input))
        printf("✅ '%s' is a valid IDENTIFIER.\n", input);
    else if (isConstant(input))
        printf("✅ '%s' is a valid CONSTANT.\n", input);
    else if (isOperator(input))
        printf("✅ '%s' is a valid OPERATOR.\n", input);
    else
        printf("❌ '%s' is NOT a valid identifier, constant, or operator.\n", input);

    return 0;
}

============================================================================================================
4.write a program to implement DFA that recognizes identifiers,constants,and operators??
#include <stdio.h>
#include <ctype.h>
#include <string.h>

// DFA for identifier
int isIdentifier_DFA(char str[]) {
    int state = 0;
    for (int i = 0; i < strlen(str); i++) {
        char ch = str[i];
        switch(state) {
            case 0:
                if (isalpha(ch))
                    state = 1;
                else
                    return 0;
                break;
            case 1:
                if (isalnum(ch))
                    state = 1;
                else
                    return 0;
                break;
        }
    }
    return (state == 1);
}

// DFA for constant
int isConstant_DFA(char str[]) {
    int state = 0;
    for (int i = 0; i < strlen(str); i++) {
        char ch = str[i];
        switch(state) {
            case 0:
            case 1:
                if (isdigit(ch))
                    state = 1;
                else
                    return 0;
                break;
        }
    }
    return (state == 1);
}

// DFA for operator
int isOperator_DFA(char str[]) {
    if (strlen(str) == 1) {
        char ch = str[0];
        if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '=')
            return 1;
    }
    return 0;
}

int main() {
    char token[100];

    printf("Enter a token: ");
    scanf("%s", token);

    if (isIdentifier_DFA(token))
        printf("✅ '%s' is a valid IDENTIFIER (DFA).\n", token);
    else if (isConstant_DFA(token))
        printf("✅ '%s' is a valid CONSTANT (DFA).\n", token);
    else if (isOperator_DFA(token))
        printf("✅ '%s' is a valid OPERATOR (DFA).\n", token);
    else
        printf("❌ '%s' is INVALID.\n", token);

    return 0;
}

===============================================================================================================
5.developemnt and implementation of lexical analysis block?
#include <stdio.h>
#include <ctype.h>
#include <string.h>

// Keywords list
char keywords[10][10] = {"int", "float", "return", "if", "else", "while", "for"};

int isKeyword(char *str) {
    for (int i = 0; i < 10; i++) {
        if (strcmp(str, keywords[i]) == 0)
            return 1;
    }
    return 0;
}

int main() {
    char code[100], token[20];
    int i = 0, j = 0;

    printf("Enter a line of code: ");
    fgets(code, sizeof(code), stdin);

    while (code[i] != '\0') {
        if (isspace(code[i])) {
            i++;
            continue;
        }

        // Identifier / Keyword
        if (isalpha(code[i]) || code[i] == '_') {
            j = 0;
            while (isalnum(code[i]) || code[i] == '_') {
                token[j++] = code[i++];
            }
            token[j] = '\0';

            if (isKeyword(token))
                printf("Keyword     : %s\n", token);
            else
                printf("Identifier  : %s\n", token);
        }
        // Numbers
        else if (isdigit(code[i])) {
            j = 0;
            while (isdigit(code[i])) {
                token[j++] = code[i++];
            }
            token[j] = '\0';
            printf("Constant    : %s\n", token);
        }
        // Operators and Symbols
        else {
            switch (code[i]) {
                case '+': case '-': case '*': case '/': case '=':
                    printf("Operator    : %c\n", code[i]);
                    break;
                case ';': case '(': case ')': case '{': case '}':
                    printf("Separator   : %c\n", code[i]);
                    break;
                default:
                    printf("Unknown     : %c\n", code[i]);
            }
            i++;
        }
    }

    return 0;
}
===========================================================================================================
7.Implement a program for predictive parsing algorithm?
#include <stdio.h>
#include <string.h>

char stack[100];
int top = -1;

// Push onto stack
void push(char c) {
    stack[++top] = c;
}

// Pop from stack
char pop() {
    return stack[top--];
}

// Peek top of stack
char peek() {
    return stack[top];
}

// Function to print current stack contents
void printStack() {
    for (int i = 0; i <= top; i++) {
        printf("%c", stack[i]);
    }
}

// Main parse function using predictive parsing
void parseInput(char input[]) {
    int i = 0;
    char symbol, current;

    push('$');   // End marker
    push('E');   // Start symbol

    printf("\nStack\t\tInput\t\tAction\n");
    printf("-----------------------------------------------\n");

    while (top >= 0) {
        symbol = peek();   // Top of stack
        current = input[i];  // Current input character

        printStack();
        printf("\t\t%s\t\t", &input[i]);

        // Terminal or end marker match
        if ((symbol == current) || (symbol == '$' && current == '$')) {
            pop();
            i++;
            printf("Match %c\n", current);
        }

        // Non-terminal rules
        else if (symbol == 'E') {
            if (current == 'i' || current == '(') {
                pop();
                push('e');  // E'
                push('T');
                printf("E → T E'\n");
            } else {
                printf("Error: No rule for E\n");
                break;
            }
        }
        else if (symbol == 'e') {  // E'
            if (current == '+') {
                pop();
                push('e'); push('T'); push('+');
                printf("E' → + T E'\n");
            } else if (current == ')' || current == '$') {
                pop();  // E' → ε
                printf("E' → ε\n");
            } else {
                printf("Error: No rule for E'\n");
                break;
            }
        }
        else if (symbol == 'T') {
            if (current == 'i' || current == '(') {
                pop();
                push('t'); push('F');  // T → F T'
                printf("T → F T'\n");
            } else {
                printf("Error: No rule for T\n");
                break;
            }
        }
        else if (symbol == 't') {  // T'
            if (current == '*') {
                pop();
                push('t'); push('F'); push('*');
                printf("T' → * F T'\n");
            } else if (current == '+' || current == ')' || current == '$') {
                pop();  // T' → ε
                printf("T' → ε\n");
            } else {
                printf("Error: No rule for T'\n");
                break;
            }
        }
        else if (symbol == 'F') {
            if (current == 'i') {
                pop();
                push('i');  // F → id
                printf("F → id\n");
            } else if (current == '(') {
                pop();
                push(')'); push('E'); push('(');  // F → ( E )
                printf("F → ( E )\n");
            } else {
                printf("Error: No rule for F\n");
                break;
            }
        }
        else {
            printf("Error: Unexpected symbol on stack\n");
            break;
        }
    }

    // Final validation
    if (peek() == '$' && input[i] == '$') {
        printf("\n✅ Input string is Accepted!\n");
    } else {
        printf("\n❌ Input string is Rejected!\n");
    }
}

int main() {
    char input[100];

    printf("Enter input string (use i for id, end with $): ");
    scanf("%s", input);

    parseInput(input);

    return 0;
}

=============================================================================================================
8.implement a program for the design of recursive descent parser
#include <stdio.h>
#include <string.h>

char input[100];
int i = 0;

// Function declarations for non-terminals
void E();
void Eprime();
void T();
void Tprime();
void F();

void error() {
    printf("\n❌ Syntax Error at position %d\n", i);
    exit(1);
}

void match(char expected) {
    if (input[i] == expected) {
        i++;
    } else {
        error();
    }
}

// E → T E'
void E() {
    T();
    Eprime();
}

// E' → + T E' | ε
void Eprime() {
    if (input[i] == '+') {
        match('+');
        T();
        Eprime();
    }
    // else epsilon (do nothing)
}

// T → F T'
void T() {
    F();
    Tprime();
}

// T' → * F T' | ε
void Tprime() {
    if (input[i] == '*') {
        match('*');
        F();
        Tprime();
    }
    // else epsilon (do nothing)
}

// F → ( E ) | i
void F() {
    if (input[i] == '(') {
        match('(');
        E();
        match(')');
    } else if (input[i] == 'i') {
        match('i');
    } else {
        error();
    }
}

int main() {
    printf("Enter the input string (use 'i' for id and end with $): ");
    scanf("%s", input);

    E();  // Start parsing from E

    if (input[i] == '$') {
        printf("\n✅ Input string is Accepted!\n");
    } else {
        printf("\n❌ Input string is Rejected. Extra characters found!\n");
    }

    return 0;
}

===============================================================================================================
12.implememtation of generating three address code ?
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int tempVar = 1;

// Function to generate temporary variable name
char* newTemp(char *t) {
    sprintf(t, "t%d", tempVar++);
    return t;
}

int main() {
    char expr[100];
    char op[] = {'*', '/', '+', '-'};
    int i, j;

    printf("Enter an expression (e.g. a+b*c-d): ");
    scanf("%s", expr);

    int len = strlen(expr);
    char newExpr[100];
    strcpy(newExpr, expr);

    // Loop through all operators in precedence order
    for (j = 0; j < 4; j++) {
        for (i = 0; i < len; i++) {
            if (newExpr[i] == op[j]) {
                char left = newExpr[i - 1];
                char right = newExpr[i + 1];
                char temp[5];

                // Create a new temp variable
                printf("%s = %c %c %c\n", newTemp(temp), left, newExpr[i], right);

                // Replace the sub-expression in original string with the new temp
                newExpr[i - 1] = temp[0];  // t1
                // Shift the rest of the string
                int k = i + 2, l = i;
                while (newExpr[k] != '\0') {
                    newExpr[l++] = newExpr[k++];
                }
                newExpr[l] = '\0';
                len = strlen(newExpr);
                i = 0; // Restart from beginning for new expression
            }
        }
    }

    return 0;
}

